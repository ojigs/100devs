// To-do
// In this challenge, you will reimplement a tiny part of React from scratch! It’s not as hard as it sounds.

// Scroll through the sandbox preview. Notice that it shows four test cases. They correspond to the examples you’ve seen earlier on this page. Your task is to implement the getFinalState function so that it returns the correct result for each of those cases. If you implement it correctly, all four tests should pass.

// You will receive two arguments: baseState is the initial state (like 0), and the queue is an array which contains a mix of numbers (like 5) and updater functions (like n => n + 1) in the order they were added.

// Your task is to return the final state, just like the tables on this page show!

// export function getFinalState(baseState, queue) {
//     let finalState = baseState;

//     // TODO: do something with the queue...

//     return finalState;
//   }

export function getFinalState(baseState, queue) {
  let finalState = baseState;

  // TODO: do something with the queue...
  // queue.reduce((a,c) => a + c)
  for (let i = 0; i < queue.length; i++) {
    if (typeof queue[i] === "function") {
      // received function as parameter
      // replace n in the function with final state and return the result
      finalState = queue[i](finalState);
    } else {
      finalState = queue[i];
    }
  }

  return finalState;
}
